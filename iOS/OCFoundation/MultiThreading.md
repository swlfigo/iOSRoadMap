# Multi Threading 多线程

## 进程、线程与队列

#### 1.进程的定义

- `进程`是指在系统中正在运行的一个应用程序，如微信、支付宝app都是一个进程
- 每个`进程`之间是独立的，每个`进程`均运行在专用的且受保护的内存

#### 2.线程的定义

- `线程`是`进程`的基本执行单元，一个`进程`的所有任务都在线程中执行
- `进程`想要执行任务，必须得有`线程`，`进程`至少要有一条`线程`
- 程序启动会默认开启一条`线程`，这条`线程`被成为`主线程`或`UI线程`

#### 3.进程与线程的关系和区别

- 地址空间：同一`进程`的`线程`共享本进程的地址空间，而进程之间则是独立的地址空间
- 资源拥有：同一`进程`内的`线程`共享本进程的资源如内存、I/O、cpu等，但是`进程`之间的资源是独立的
- 一个`进程`崩溃后，在保护模式下不会对其他`进程`产生影响，但是一个`线程`崩溃整个`进程`都死掉，所以`多进程`要比`多线程`健壮
- `进程`切换时，消耗的资源大、效率高。所以设计到频繁的切换时，使用`线程`要好于`进程`。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用`线程`而不能用`进程`
- 执行过程：每个独立的`进程`有一个程序运行的入口、顺序执行序列和程序入口。但是`线程`不能独立执行，必须依存在应用程序中，由应用程序提供多个`线程`执行控制
- `线程`是处理器调度的基本单位，但`进程`不是

#### 4.进程与线程的关系图

![](http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2021-02-26-064756.jpg)

#### 5.队列的定义

队列，又称为伫列（`queue`），是先进先出（`FIFO： First-In-First-Out`）的线性表，在具体应用中通常用链表或者数组来实现。装载线程任务的队形结构。队列只允许在后端（称为`rear`）进行插入操作，在前端（称为`front`）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加

![img](http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2021-02-26-065337.jpg)

#### 6.队列和线程的关系

两者是没有关系的，可以这么理解：

- `队列`负责调度任务，`线程`执行任务
- 在银行（`进程`）中，有4个工作窗口（`线程`），而只有一条队伍（`队列`）
- 窗口（`线程`）只负责为排队的人办理业务，并不会管队伍（`队列`）是怎么排的

#### 7.线程和runloop的关系

- `runloop与线程是一一对应的`——一个`runloop`对应一个核心的`线程`，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里
- `runloop是来管理线程的`——当线程的`runloop`被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务
- `runloop` 在第一次获取时被创建，在线程结束时被销毁
  - 对于主线程来说，`runloop`在程序一启动就默认创建好了
  - 对于子线程来说，`runloop`是懒加载的——只有当我们使用的时候才会创建，所以在子线程用定时器要注意：**确保子线程的`runloop`被创建**，不然定时器不会回调

#### 8.影响任务执行速度的因素

以下因素都会对任务的执行速度造成影响：

- cpu的调度
- 线程的执行速率
- 队列情况
- 任务执行的复杂度
- 任务的优先级

## 多线程

#### 1.多线程原理

- 同一时间，CPU只能处理一条线程，只有一条线程在工作（执行）
- 多线程并发（同时）执行，其实就是CPU执行快速地在多条线程之间调度（切换）

#### 2.多线程意义

- 优点
  - 能适当提高程序的执行效率
  - 能适当提高资源的利用率（CPU、内存）
  - 线程上的任务执行完成后，线程会自动销毁
- 缺点
  - 开启线程需要占用一定的内存空间（默认情况下，每一个线程都占`512KB`，创建线程大约需要`90毫秒`的创建时间）
  - 如果开启大量的线程，会占用大量的内存空间，降低程序的性能
  - 线程越多，CPU在调用线程上的开销就越大
  - 程序设计更加复杂，比如线程间的通信、多线程的数据共享

#### 2.多线程生命周期



![img](http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2021-02-26-095429.jpg)

**多线程的生命周期是：新建 - 就绪 - 运行 - 阻塞 - 死亡**



- `新建`：实例化线程对象
- `就绪`：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。
- `运行`：CPU 负责调度可调度线程池中线程的执行。线程执行完成之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。
- `阻塞`：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。`sleepForTimeInterval`（休眠指定时长），`sleepUntilDate`（休眠到指定日期），`@synchronized(self)：`（互斥锁）。
- `死亡`：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中止执行/在主线程中止线程对象



#### 4.线程池的原理



![img](http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2021-02-26-095713.jpg)



- 若`线程池大小`小于`核心线程池大小`时
  - 创建线程执行任务
- 若`线程池大小`大于等于`核心线程池大小`时
  1. 先判断线程池工作队列是否已满
  2. 若没满就将任务push进队列
  3. 若已满时，且`maximumPoolSize>corePoolSize`，将创建新的线程来执行任务
  4. 反之则交给`饱和策略`去处理

| 参数名        | 代表意义                                                     |
| ------------- | ------------------------------------------------------------ |
| corePoolSize  | 线程池的基本大小（核心线程池大小）                           |
| maximumPool   | 线程池的最大大小                                             |
| keepAliveTime | 线程池中超过corePoolSize树木的空闲线程的最大存活时间         |
| unit          | keepAliveTime参数的时间单位                                  |
| workQueue     | 任务阻塞队列                                                 |
| threadFactory | 新建线程的工厂                                               |
| handler       | 当提交的任务数超过maxmumPoolSize与workQueue之和时， 任务会交给RejectedExecutionHandler来处理 |

饱和策略有如下四个：

- `AbortPolicy`直接抛出RejectedExecutionExeception异常来阻止系统正常运行
- `CallerRunsPolicy`将任务回退到调用者
- `DisOldestPolicy`丢掉等待最久的任务
- `DisCardPolicy`直接丢弃任务

#### 4.多线程实现方案

| 技术方案    | 简介                                                         | 语言 | 线程生命周期 | 使用评率 |
| ----------- | ------------------------------------------------------------ | ---- | ------------ | -------- |
| pthread     | 一套通用的多线程API 适用于Unix/Linux/Windows等系统 跨平台/可移植 使用难度大 | C    | 程序员管理   | 几乎不用 |
| NSThread    | 使用更加面向对象 简单易用，可直接操作线程对象                | OC   | 程序员管理   | 偶尔使用 |
| GCD         | 旨在替代NSThread等线程技术 充分利用设备的多核                | C    | 自动管理     | 经常使用 |
| NSOperation | 基于GCD（底层是GCD） 比GCD多了一些更简单实用的功能 使用更加面向对象 | OC   | 自动管理     | 经常使用 |

#### 5.GCD和NSOperation的区别

- `GCD`仅仅支持`FIFO`队列，不支持异步操作之间的依赖关系设置。而`NSOperation`中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整
- `NSOperation`支持`KVO`，可以观察任务的执行状态
- `GCD`更接近底层，`GCD`在追求性能的底层操作来说，是速度最快的
- 从异步操作之间的事务性，顺序行，依赖关系。`GCD`需要自己写更多的代码来实现，而`NSOperation`已经内建了这些支持
- 如果异步操作的过程需要更多的被交互和UI呈现出来，`NSOperation`更好；底层代码中，任务之间不太互相依赖，而需要更高的并发能力，`GCD`则更有优势

#### 6.线程间通讯



![img](http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2021-02-26-100029.jpg)



- `直接消息传递`: 通过`performSelector`的一系列方法，可以实现由某一线程指定在另外的线程上执行任务。因为任务的执行上下文是目标线程，这种方式发送的消息将会自动的被序列化
- `全局变量、共享内存块和对象`: 在两个线程之间传递信息的另一种简单方法是使用全局变量，共享对象或共享内存块。尽管共享变量既快速又简单，但是它们比直接消息传递更脆弱。必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性。 否则可能会导致竞争状况，数据损坏或崩溃。
- `条件执行`: 条件是一种同步工具，可用于控制线程何时执行代码的特定部分。您可以将条件视为关守，让线程仅在满足指定条件时运行。
- `Runloop sources`: 一个自定义的 Runloop source 配置可以让一个线程上收到特定的应用程序消息。由于 Runloop source 是事件驱动的，因此在无事可做时，线程会自动进入睡眠状态，从而提高了线程的效率
- `Ports and sockets`:基于端口的通信是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种非常可靠的技术。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用 Runloop source 来实现端口，因此当端口上没有数据等待时，线程将进入睡眠状态
- `消息队列`: 传统的多处理服务定义了先进先出（FIFO）队列抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如其他一些通信技术高效
- `Cocoa 分布式对象`: 分布式对象是一种 Cocoa 技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，尽管在这些进程之间进行事务的开销也很高



## Reference

[1. iOS探索 多线程原理](https://juejin.cn/post/6844904121468715015)

